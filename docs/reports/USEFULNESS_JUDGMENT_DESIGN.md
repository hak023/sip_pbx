# 유용성 판단 설계 리포트 (Usefulness Judgment Design)

**기준 문서**: [USEFULNESS_PROMPT_RECOMMENDATIONS.md](./USEFULNESS_PROMPT_RECOMMENDATIONS.md)  
**목적**: 리서치·권장사항을 반영한 “유용함 판단” 기능의 설계를 정리하고, 구현·운영 가이드를 제시한다.

---

## 1. 개요

### 1.1 목적

- **통화 종료 후** 전사(transcript)를 분석해, **지식 베이스(VectorDB)에 저장할 가치가 있는지** 판단한다.
- “유용하다”고 판단된 경우에만 추출 정보(`extracted_info`)를 청킹·임베딩하여 저장함으로써, **노이즈 저장을 줄이고 FAQ/지식 품질을 유지**한다.

### 1.2 설계 원칙 (리서치 반영)

| 원칙 | 내용 |
|------|------|
| **저장 단위** | QA 쌍(FAQ 스타일), 실행 가능한 정보, 이슈 해결 내용 등 “재사용 가능한 지식” 단위로 판단. |
| **품질 우선** | PII만 있는 대화, 인사/맥락만, 미해결·유보만, 원문에 없는 환각은 “유용하지 않음”으로 처리. |
| **시스템 관점** | 프롬프트뿐 아니라 입력/출력 스키마, 파이프라인 위치, 실패 시 폴백을 함께 설계. |
| **확장 고려** | 추후 “누적 기반 추출”, “검토 워크플로(승인/편집/거절)”를 붙일 수 있도록 출력·메타데이터를 정의. |

---

## 2. 입력·출력 설계

### 2.1 입력

| 항목 | 타입 | 설명 |
|------|------|------|
| `transcript` | string | 판단 대상 텍스트. 통화 전사 전체 또는 특정 화자만 필터링한 문자열. (현재 구현: 2000자까지 전달) |
| `speaker` | string | `"caller"` \| `"callee"` \| `"both"`. 누구 발화를 기준으로 했는지 (로깅·메타데이터용). |
| `call_id` | string | 통화 ID. 로그·CDR·저장 메타데이터 연계용. |

### 2.2 출력 스키마 (Judgment Result)

리서치 권장 및 기존 구현을 반영한 **표준 출력**:

```json
{
  "is_useful": true,
  "confidence": 0.85,
  "reason": "기상청 주차 방법에 대한 구체적 답변이 포함되어 재사용 가능.",
  "extracted_info": [
    {
      "text": "주차는 원하시는 때 하시면 됩니다.",
      "category": "FAQ",
      "keywords": ["주차", "안내"],
      "contains_pii": false
    }
  ]
}
```

| 필드 | 타입 | 필수 | 설명 |
|------|------|------|------|
| `is_useful` | boolean | ✅ | 저장할 가치가 있으면 `true`. |
| `confidence` | float [0, 1] | ✅ | 판단 신뢰도. 하위 호환 및 필터링(예: `min_confidence` 미만 시 저장 스킵)에 사용. |
| `reason` | string | ✅ | 판단 이유. **50자 이내** 권장(토큰·잘림 방지). |
| `extracted_info` | array | ✅ | 추출할 정보 목록. 비어 있으면 “유용하지만 구체적 블록 없음” → 호출 측에서 전체 텍스트 청킹 등 폴백 가능. |
| `extracted_info[].text` | string | ✅ | 저장 후보 텍스트. **원문에 명시된 내용만** 포함(환각 금지). |
| `extracted_info[].category` | string | ✅ | 아래 **카테고리 Enum** 중 하나. |
| `extracted_info[].keywords` | string[] | 권장 | 검색·필터링용 키워드. |
| `extracted_info[].contains_pii` | boolean | 선택 | 개인정보 포함 여부. 저장 파이프라인에서 익명화/검토 대상 플래그용. |

### 2.3 카테고리 Enum (리서치 반영)

리서치의 “저장할 것”과 “출력 보강”을 반영한 **category** 값:

| 값 | 설명 |
|----|------|
| `FAQ` | 재사용 가능한 질문·답변 쌍. |
| `이슈해결` | 문의/불만에 대한 해결 방법·다음 단계가 명확한 경우. |
| `약속` | 일시·장소·담당자 등 구체적 약속. |
| `정보` | 영업시간, 절차, 조건 등 사실 정보. |
| `지시` | 업무 지시, “항상 A로 해주세요” 등. |
| `선호도` | “B는 싫어합니다” 등 재사용 가능한 선호. |
| `기타` | 위에 해당하지 않으나 재사용 가능한 정보. |

프롬프트에는 **`약속|정보|지시|선호도|FAQ|이슈해결|기타`** 로 명시하여, 검색·필터링과 추후 통계에 활용할 수 있게 한다.

---

## 3. 판단 기준 (프롬프트 규칙)

리서치 문서 3.1·3.2·3.3을 반영한 **명시적 규칙**으로 프롬프트에 넣는다.

### 3.1 유용하다고 판단할 경우 (`is_useful = true`)

- **실행 가능한 Q&A**: 구체적 사실·절차·조건이 포함된 질문·답변.
- **재사용 가능한 FAQ**: 다른 통화에서도 그대로 쓸 수 있는 Q&A.
- **이슈 해결 내용**: 문의/불만에 대한 해결 방법·조치·다음 단계가 명확한 경우.
- **약속·일정·연락처**: 시간, 장소, 담당자, 연락처 등 (PII는 저장 시 별도 정책 적용).
- **업무 지시·선호도**: “항상 A로 해주세요”, “B는 싫어합니다” 등 재사용 가능한 지시·선호.

### 3.2 유용하지 않다고 판단할 경우 (`is_useful = false`)

- **PII만 있는 경우**: 개인을 특정할 수 있는 정보만 있고, 일반화·익명화 없이 저장하는 경우.
- **인사·맥락만**: “네”, “알겠습니다”, “날씨가 좋네요” 등 지식으로 재사용할 내용이 없는 경우.
- **미해결·유보만**: “확인 후 연락드리겠습니다”, “잘 모르겠습니다”만 있고 실제 정보가 없는 경우.
- **환각 금지**: **원문에 없는 질문/답변을 만들지 말 것.** 원문에 명시된 내용만 추출.

### 3.3 프롬프트 문구 (구현용)

아래 블록을 `judge_usefulness` 프롬프트의 **판단 기준** 섹션으로 사용하는 것을 권장한다. (이미 동일한 문구가 `llm_client.py`에 반영되어 있으면 유지.)

```
**유용하다고 판단할 경우:**
- 실행 가능한 질문·답변 (구체적 사실, 절차, 조건이 포함된 경우)
- 다른 통화에서도 재사용 가능한 FAQ 성격의 대화
- 문의/이슈에 대한 해결 방법·다음 단계가 명확한 경우
- 약속·일정·연락처·업무 지시·선호도 등 재사용 가능한 정보 (개인정보는 저장 시 별도 정책 적용)

**유용하지 않다고 판단할 경우:**
- 개인을 특정할 수 있는 정보만 있는 경우 (이름, 전화번호, 주소 등)
- 인사, 맞장구, 날씨 등 지식으로 쓸 내용이 없는 경우
- "확인 후 연락드리겠습니다" 등 미해결·유보만 있는 경우
- 원문에 없는 질문/답변을 만들어 내지 말 것 (원문에 명시된 내용만 추출)
```

---

## 4. 파이프라인 통합

### 4.1 호출 위치

- **정규 통화(사람–사람) 종료 후**: 녹음/전사 완료 → Knowledge Extractor가 해당 통화의 transcript를 로드 → **화자 필터**(caller/callee/both) 적용 → `judge_usefulness(transcript, speaker, call_id)` 호출.
- **AI 통화**: 현재 정책상 지식 추출을 스킵하는 경우가 많음. 정책 변경 시 동일한 `judge_usefulness` 인터페이스를 사용하면 됨.

### 4.2 후속 처리 (현재 구현)

1. `is_useful === false` → 저장 스킵, 로그만 남김.
2. `confidence < min_confidence` → 저장 스킵.
3. `is_useful === true` 이고 `confidence >= min_confidence`:
   - `extracted_info`가 있으면 각 항목을 청킹 → 임베딩 → VectorDB `upsert`.
   - `extracted_info`가 비어 있으면 전체 `transcript`를 하나의 “기타” 블록으로 청킹하여 저장(기존 동작 유지).

### 4.3 PII 플래그 활용 (선택)

- `extracted_info[].contains_pii === true`인 항목은:
  - 저장 전 **익명화 파이프라인**을 거치거나,
  - **검토 대기열**에만 넣고, 승인 시에만 저장하도록 할 수 있다.
- 현재 스키마에 `contains_pii`를 선택 필드로 두고, 프롬프트에 “개인정보가 포함되면 contains_pii: true로 표시”만 추가해도 된다.

---

## 5. 설정·안정성

### 5.1 설정

| 설정 | 권장값 | 설명 |
|------|--------|------|
| `judgment_max_output_tokens` | 1024 이상 (필요 시 2048) | JSON이 잘리지 않도록. `reason` 50자 이내 유지 시 토큰 증가는 제한적. |
| `temperature` (judgment 전용) | 0.2 ~ 0.3 | 일관된 판단·JSON 형식 유지를 위해 낮게. |
| `min_confidence` (호출 측) | 0.7 등 | 이 값 미만이면 저장 스킵. |

### 5.2 실패·잘림 처리

- **JSON 파싱 실패**: 기존처럼 기본값 반환  
  `{ "is_useful": false, "confidence": 0.0, "reason": "...", "extracted_info": [] }`  
  → 저장 스킵, 로그로 원인 추적.
- **응답 잘림 (finish_reason = MAX_TOKENS)**:
  - `judgment_max_output_tokens` 상향.
  - 가능하면 `reason`을 50자 이내로 제한해 토큰 여유 확보.
  - 필요 시 **재시도 1회**(동일 입력) 후 실패하면 위 기본값 적용.

---

## 6. 구현 체크리스트

- [ ] **프롬프트**: 위 3.1·3.2·3.3 규칙이 `judge_usefulness` 프롬프트에 포함되어 있는지 확인.
- [ ] **출력 스키마**: `category`에 `FAQ`, `이슈해결` 포함 여부 확인. (`기타` 유지.)
- [ ] **선택**: `extracted_info[].contains_pii` 필드 요청 및 저장 파이프라인에서 활용 여부 결정.
- [ ] **설정**: `judgment_max_output_tokens` 1024 이상(필요 시 2048), judgment 전용 `temperature` 0.3 수준 적용.
- [ ] **로깅**: `finish_reason` 로깅으로 잘림(MAX_TOKENS) 발생 시 알 수 있도록 유지.

---

## 7. 향후 확장 (리서치 1.3·4 반영)

| 단계 | 내용 |
|------|------|
| **누적 기반 추출** | 여러 통화에서 동일/유사 주제를 클러스터링한 뒤, 요약·중복 제거 후 지식으로 저장. |
| **검토 워크플로** | 추출 결과를 단순 UI로 검토(승인/수정/거절)한 뒤 VectorDB에 반영. 승인률·정확도 향상 기대. |
| **PII 파이프라인** | `contains_pii: true`인 항목만 익명화 또는 검토 대기열로 보내는 단계 추가. |

---

## 8. 요약

- **유용성 판단**은 “저장할 가치가 있는 지식”만 골라 VectorDB 품질을 지키기 위한 단계다.
- 리서치 권장사항을 **판단 기준·출력 스키마(category, 선택적 PII 플래그)·설정·실패 처리**에 반영한 설계로 정리했으며, 현재 `judge_usefulness` 구현과 호출 흐름(Knowledge Extractor)과 정합된다.
- 위 체크리스트와 설정을 적용한 뒤, 필요 시 누적 추출·검토 UI·PII 파이프라인을 단계적으로 붙이면 된다.
